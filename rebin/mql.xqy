xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Aug 1, 2013 21:44 (UTC-04) by REx v5.25 which is Copyright (c) 1979-2013 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: mql.ebnf -backtrack -tree -xquery :)

(:~
 : The parser that was generated for the mql grammar.
 :)
module namespace p="mql";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo := 14;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 15;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  59, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 2, 2, 2, 2,
  2, 4, 5, 2, 6, 7, 8, 9, 2, 10, 11, 12, 13, 14, 15, 16, 16, 17, 16, 18, 2, 2, 19, 2, 2, 2, 20, 20, 21, 20, 22, 20, 23,
  20, 24, 20, 20, 25, 26, 27, 28, 29, 20, 30, 31, 32, 33, 20, 20, 20, 34, 35, 2, 2, 2, 2, 2, 2, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 20, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 20, 2, 2, 2, 2, 2
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  54, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
  58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 90, 122, 153, 212,
  180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180,
  180, 180, 180, 180, 180, 180, 180, 180, 180, 59, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 2, 2, 2, 2, 2, 4, 5, 2, 6, 7, 8, 9, 2, 10, 11, 12, 13, 14, 15, 16, 16, 17, 16, 18, 2,
  2, 19, 2, 2, 20, 20, 21, 20, 22, 20, 23, 20, 24, 20, 20, 25, 26, 27, 28, 29, 20, 30, 31, 32, 33, 20, 20, 20, 34, 35,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 20, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 20, 2, 2, 2, 2, 2
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  55296, 1114111, 2
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 2088, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 3840, 3840, 3840, 3852, 9388, 9388, 9388, 3875, 9388, 9388, 9388, 3897,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 7234, 9388,
  4526, 9388, 7235, 9388, 7232, 9388, 9388, 9388, 7236, 9388, 9388, 4526, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 3915, 3859, 3939, 3955, 9388, 9388, 9388, 6739, 9388, 3923, 9388, 9388, 9388, 6740, 9388, 9388, 3919,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 3974, 4784, 3998, 4034, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9294, 9388, 7449,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 10211, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 4054, 4822, 4076, 4097, 9388, 4526, 9388, 7235, 9388, 7232, 9388, 9388, 9388, 7236, 9388,
  9388, 4526, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 6073, 9388, 8624, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 3958, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4054,
  4822, 4076, 4097, 9388, 4526, 9388, 4121, 9388, 7232, 9388, 9388, 9388, 7236, 9388, 8121, 4526, 4146, 9388, 9388,
  9388, 9388, 9388, 9220, 9388, 9388, 9388, 4168, 4186, 4234, 9388, 9388, 9388, 9388, 4278, 5533, 4010, 9388, 7134,
  5930, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 4301, 4038, 4317, 4338, 3899, 5956, 4394, 4363, 4297, 9243, 4397, 9388, 4301,
  4386, 8066, 4037, 5956, 4396, 9387, 9785, 8067, 9388, 8757, 9383, 8753, 7190, 9379, 7194, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4413, 7642, 4435, 4456, 8575, 4644,
  4571, 4500, 8383, 7681, 4574, 4523, 4542, 4563, 8920, 4625, 7311, 4573, 8815, 4152, 4128, 6140, 9846, 5017, 9842,
  6177, 4130, 4590, 9388, 4621, 4641, 9388, 4440, 9388, 4660, 9388, 4677, 7267, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 4699, 6913, 4435, 4456, 8575, 4644, 4571, 4500, 8383, 7681, 4574, 4523, 4542, 4563, 8920, 4625, 7311, 4573,
  8687, 4152, 4128, 6140, 9846, 5017, 9842, 6177, 4130, 4590, 9388, 4621, 4641, 9388, 4440, 9388, 4660, 9388, 4677,
  7267, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4413, 7642, 4435, 4456, 8575, 4644, 4571, 4500, 8383, 7681, 4574,
  4523, 4542, 4563, 8920, 4625, 7311, 4573, 5021, 4152, 4128, 6140, 9846, 5017, 9842, 6177, 4130, 4757, 9388, 4780,
  4641, 9388, 4440, 9388, 4660, 9388, 4677, 7267, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4413, 7642, 4435, 4456,
  8575, 4644, 4571, 4500, 8383, 7681, 4574, 4523, 4542, 4563, 8920, 4625, 7311, 4573, 5021, 4152, 4128, 6103, 9846,
  5017, 9842, 6190, 4130, 4757, 9388, 9388, 4641, 9388, 4440, 9388, 4660, 9388, 4677, 7267, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 4413, 7642, 4435, 4456, 8575, 4644, 4571, 4500, 8383, 7681, 4574, 4523, 4542, 4563, 4060, 4625,
  7311, 4573, 5021, 4152, 4128, 6103, 9846, 5017, 9842, 4597, 4130, 4757, 9388, 9388, 4800, 9388, 4440, 9388, 4660,
  9388, 4677, 7267, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4413, 7642, 4435, 4456, 8575, 4644, 4571, 4500, 8383,
  7681, 4574, 4523, 4542, 4563, 8920, 4625, 7311, 4573, 5021, 4152, 4128, 6103, 9846, 5017, 9842, 4597, 4130, 4757,
  9388, 9388, 4800, 9388, 4440, 9388, 4660, 9388, 4677, 7267, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4413, 7642,
  4435, 4456, 8575, 4644, 4571, 4500, 8383, 7681, 4574, 4523, 4542, 4563, 8920, 4625, 7311, 4573, 5021, 4152, 4128,
  6103, 9846, 5017, 9842, 4597, 4130, 4757, 9388, 9388, 4800, 9388, 9388, 9388, 4660, 9388, 9388, 7267, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 4413, 7642, 4435, 4456, 8575, 4644, 4571, 4500, 8383, 7681, 4574, 4818, 4542, 4563,
  8920, 4625, 7311, 4573, 5021, 4152, 4128, 6103, 9846, 5017, 9842, 4597, 4130, 4757, 9388, 9388, 4800, 9388, 9388,
  9388, 4660, 9388, 9388, 7267, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 8159, 4846,
  7940, 9388, 7506, 4849, 9388, 9388, 4838, 10191, 9388, 8159, 4848, 7942, 7507, 10192, 9388, 8207, 7938, 8203, 6013,
  7934, 6017, 9388, 9388, 9388, 4865, 9388, 9388, 9388, 4887, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  10233, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948,
  9388, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388,
  6314, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017,
  9842, 4597, 4989, 4601, 9388, 9388, 9388, 9435, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 4907, 9388, 4605, 4924, 9388, 4484, 4571, 5683, 9388, 9503, 4574, 4948, 5170, 4965, 4871, 9388, 3982,
  4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 5013, 4601, 9388, 9388, 5038, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 9997, 4924, 9388, 7003, 4571, 5683, 9388, 5059,
  4574, 4948, 9388, 4965, 4871, 9388, 6692, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 5087, 9388,
  9388, 9388, 9388, 5725, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605,
  4924, 9388, 7052, 4571, 5683, 9388, 5114, 4574, 4948, 9388, 4965, 4871, 9388, 4248, 4573, 5021, 4152, 4128, 5188,
  9846, 5017, 5142, 4597, 4130, 4601, 9388, 9388, 5166, 9388, 9388, 9388, 5186, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 4907, 9388, 5204, 4924, 9388, 8518, 4571, 5683, 9388, 5230, 4574, 4948, 9388, 4965, 4871,
  9388, 7311, 4573, 5021, 5266, 4128, 9388, 9846, 5017, 5292, 4597, 4130, 4601, 6148, 7589, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 5317, 4924, 9388, 6290, 4571, 5683,
  9388, 9503, 4574, 4948, 9388, 5343, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130,
  4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907,
  9388, 4605, 4924, 9388, 6290, 4571, 5683, 9388, 5367, 4574, 4948, 4802, 4965, 4871, 9388, 7311, 4573, 5021, 4152,
  4128, 9388, 5396, 5017, 5417, 4597, 5437, 4601, 9388, 5457, 9388, 10140, 9388, 9388, 9388, 9388, 8788, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 8711, 4571, 5683, 9388, 5479, 4574, 4948, 8290,
  4965, 4871, 9388, 7311, 4573, 5021, 4713, 4128, 5022, 9846, 5017, 9842, 4597, 4130, 6867, 8392, 9388, 9388, 9388,
  9388, 9388, 9388, 5528, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 5549, 4924, 9388, 8649,
  4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311, 4573, 5021, 5586, 4128, 9388, 9846, 5017, 9842,
  4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 4907, 9388, 4605, 4924, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311, 4573,
  5021, 4152, 4128, 8178, 5612, 5017, 9842, 4597, 4130, 4601, 9388, 5633, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 8902, 4571, 5683, 9388, 5654, 4574,
  4948, 9388, 4965, 4871, 9388, 5706, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 6856, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924,
  9388, 9947, 4571, 5683, 9388, 5741, 4574, 4948, 6596, 4965, 4871, 9388, 9566, 4573, 5021, 5757, 4128, 9388, 9846,
  5017, 9842, 4597, 4130, 6845, 7126, 9388, 9388, 9388, 9408, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 9269, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388,
  7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 6290, 4571, 5683, 9388,
  9503, 4574, 4948, 9389, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 5773, 4597, 5798, 4601,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388,
  4605, 4924, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128,
  9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 7225, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 4907, 9388, 7274, 4924, 5818, 5844, 5596, 5683, 9388, 9503, 5860, 5876, 4081, 4965,
  4871, 5900, 7311, 9850, 4477, 4218, 4467, 5953, 5214, 5017, 6495, 5972, 4130, 4601, 9388, 9388, 8548, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 5998, 9388, 6215, 4924, 9388, 6290, 4571,
  5683, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597,
  4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  6033, 4170, 6049, 6065, 9388, 6290, 4571, 6089, 6353, 9052, 4574, 6126, 9388, 4965, 6164, 4661, 6231, 5669, 6251,
  7886, 4128, 9388, 5421, 6247, 9842, 4597, 7622, 4601, 9388, 6905, 9388, 9872, 7783, 9388, 9388, 9388, 9388, 7336,
  6545, 6267, 5884, 6287, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 6110, 6306, 9388, 6290, 4571, 5683, 6330, 7485, 5401, 4948,
  6350, 4965, 9922, 9645, 9807, 4573, 6369, 6386, 6402, 6424, 10007, 6444, 6464, 6484, 5982, 6520, 6540, 8729, 9388,
  9388, 9388, 9388, 9388, 10260, 5638, 7096, 9388, 8871, 6561, 6577, 6593, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 6612, 4370, 6630, 6660,
  6708, 5071, 6724, 9388, 9503, 5782, 6756, 9388, 6772, 9012, 6788, 6816, 6832, 7429, 4683, 6894, 6334, 5327, 6408,
  9842, 6929, 6954, 6980, 7019, 7039, 4322, 7068, 7088, 9538, 5043, 7112, 8298, 4198, 7150, 7177, 7210, 7252, 7290,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 4907, 7308, 5690, 4924, 9388, 6290, 4571, 7327, 9388, 9503, 4574, 4948, 9388, 4965, 4871, 9388, 7311,
  4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 7352, 8141, 7387, 9388, 6290, 4571, 5683, 9388, 9503,
  4574, 4948, 9701, 7415, 7465, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388,
  9388, 9388, 7501, 9388, 7523, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605,
  4924, 9388, 6290, 4973, 5683, 9388, 9503, 4574, 4948, 10044, 4965, 4871, 4289, 7543, 4573, 5021, 7559, 4128, 9388,
  9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 10066, 9388, 10278, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 7575, 7612, 4605, 4924, 7638, 7658, 4262, 7674, 4891, 9076, 8962, 7697, 9388, 4965, 9105,
  6271, 7311, 4573, 5721, 4105, 7718, 7734, 9846, 5560, 6644, 4597, 6964, 9586, 6614, 7161, 7759, 7781, 7799, 7818,
  9834, 7845, 7861, 7880, 7902, 7922, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 3881, 4507, 7959, 9388, 6290, 4571, 7983,
  7999, 8854, 5617, 8034, 8060, 8083, 4871, 8118, 7311, 5150, 5021, 4152, 4128, 9388, 9846, 8320, 9842, 4597, 4130,
  8137, 9388, 7363, 9388, 9388, 9388, 8157, 8175, 9388, 9388, 9388, 7743, 6800, 9388, 8194, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907,
  8223, 8237, 8253, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965, 8277, 9388, 7311, 5493, 4997, 4152,
  8314, 9623, 6468, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 8593, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 4907, 9779, 7596, 8336, 8374, 8417, 5351, 8433, 8941, 9503, 6504, 4948, 9388,
  8460, 5463, 9388, 8492, 4573, 5021, 4152, 4347, 9388, 8508, 5017, 7967, 8102, 4130, 5098, 7943, 7829, 9193, 8534,
  8639, 4932, 9388, 8573, 8591, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9729, 10147, 8609, 6673, 8665,
  8681, 5683, 8703, 9898, 5380, 4948, 9166, 4965, 4871, 9388, 7864, 4573, 5021, 4152, 4128, 9388, 5504, 5441, 9842,
  4597, 7440, 4601, 8727, 9388, 8401, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 4907, 9334, 8795, 8745, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 8773, 4871, 9496, 7311, 4573,
  5021, 4152, 4128, 9388, 9846, 8811, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 8831, 9388, 6290, 4571, 5683, 9388, 9503, 4574,
  4948, 9388, 4965, 4871, 4741, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924,
  8044, 6290, 5243, 8847, 7478, 5250, 4574, 4948, 8870, 8887, 7765, 8358, 7311, 9144, 5021, 4419, 4128, 8936, 8957,
  8978, 8994, 4597, 5828, 4601, 9388, 9388, 9388, 8557, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 4907, 9388, 9028, 9044, 9388, 6290, 4571, 9068, 9388, 9503, 5126, 9092, 9388, 9134, 4871, 9160,
  7906, 4573, 9006, 4152, 9182, 9217, 9846, 9236, 7371, 4764, 5570, 6878, 6428, 8444, 4908, 9259, 9285, 4547, 9748,
  9310, 9329, 9350, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 7702, 6290, 9467, 9369, 9405,
  9503, 8916, 9424, 9388, 9459, 9483, 9388, 7802, 8093, 6448, 9519, 5937, 9535, 9554, 5802, 9201, 9582, 6994, 4601,
  9313, 9388, 9353, 7072, 6370, 9602, 5915, 10169, 9618, 9639, 9661, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 10094,
  9677, 9693, 9388, 6290, 5276, 9717, 9388, 9118, 4574, 4948, 9745, 9764, 4871, 9801, 7311, 4573, 5512, 4152, 9823,
  4018, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 9388, 4949, 9388, 9388, 9866, 9443, 7527, 9388, 9388, 9888,
  9914, 7399, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 4907, 4733, 6524, 4924, 9388, 6290, 4571, 5683, 9388, 9503, 4574, 4948, 9388, 4965,
  4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 9938, 9842, 4597, 4130, 4601, 9388, 9388, 7292, 9388, 9388,
  10269, 9388, 9388, 9388, 9963, 9982, 10023, 10060, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 10082, 8018, 10110, 10126, 9388, 6290, 4571,
  5683, 9388, 9503, 5301, 10163, 9388, 4965, 4871, 9388, 7311, 4573, 5021, 4152, 4128, 9388, 9846, 5017, 9842, 4597,
  4130, 4601, 10185, 6684, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  4907, 9388, 4605, 4924, 10208, 6290, 4723, 5683, 10316, 9503, 4574, 4948, 10227, 4965, 4871, 9388, 7311, 4573, 5021,
  4152, 4128, 9388, 9846, 5017, 9842, 4597, 4130, 4601, 9388, 9388, 10037, 9388, 9388, 9388, 9388, 9388, 6938, 9966,
  4210, 9388, 10249, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 4907, 9388, 4605, 4924, 9388, 8476, 8468, 5683, 9388, 9503, 4574, 4948,
  9388, 4965, 4871, 9388, 7311, 4573, 5021, 10294, 4128, 9388, 9846, 10310, 8261, 6203, 8009, 4601, 9388, 9388, 7023,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 8351, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388, 9388,
  9388, 9388, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 3124, 0, 0, 118,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 178, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77, 0, 0, 0, 0,
  0, 0, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8405,
  0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 56, 0, 0, 0, 0, 94, 0, 0, 0, 0, 94, 94, 0, 56, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 54, 0, 0, 0, 54, 0, 0, 0, 0, 0, 14336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 312, 0, 0, 0, 270, 95, 95, 0, 14336, 14336, 0, 0,
  0, 0, 14336, 0, 0, 0, 14336, 0, 0, 0, 0, 0, 0, 0, 600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 385, 0, 0, 0, 0, 0, 14336,
  14336, 14336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 57, 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  95, 95, 0, 238, 112640, 0, 0, 0, 79, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0,
  119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 356, 95, 95, 95, 95, 95, 95, 0, 0, 0, 177, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95,
  95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 95, 0, 454, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 81, 463, 0, 0, 0, 0, 0, 0, 0, 0, 0, 472, 473, 0, 0, 0, 0, 0, 0, 0, 616, 0, 0, 0,
  618, 0, 0, 0, 0, 0, 0, 0, 628, 0, 0, 0, 0, 0, 0, 0, 0, 355, 0, 95, 95, 95, 95, 95, 95, 0, 480, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 498, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 0, 0, 0, 270, 95, 95, 159, 95, 95, 95, 95, 0, 166, 0, 0, 0, 0, 0, 173,
  0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 574, 0, 0, 0, 0, 0, 0, 0, 296, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 58, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 513, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 119, 58, 0, 0, 0, 0,
  0, 0, 0, 0, 371, 95, 95, 0, 35840, 375, 0, 0, 0, 155, 155, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 106, 106, 64,
  106, 95, 95, 0, 0, 0, 0, 0, 119, 0, 155, 155, 155, 155, 155, 155, 155, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 155, 0,
  0, 55, 0, 57, 10299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 361, 0, 0, 10320, 0, 10320, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0, 10320, 0, 0, 117, 55, 119, 57, 9274, 10299, 0, 0, 0, 0, 0, 0, 0, 370, 0, 95, 95,
  0, 0, 0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 0, 0, 0, 154, 95, 95, 0, 95, 95, 0, 117, 6323, 119, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 95, 107, 107, 77, 107, 95, 95, 0, 238, 6323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0,
  10494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 560, 0, 0, 563, 0, 0, 0, 0, 0, 0, 119, 215, 95, 95, 95, 95, 95, 95, 95, 95, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 95, 0, 12743, 12743, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  95, 0, 0, 0, 0, 95, 95, 0, 0, 0, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10494, 0, 0, 0, 502, 502, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 119, 95, 95, 564, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 303, 0, 0, 0, 0, 0, 599, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 359, 360, 95, 0, 0, 55, 0, 57, 10299, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0,
  0, 353, 0, 0, 0, 95, 95, 95, 95, 95, 95, 95, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 74, 0, 0, 0, 0, 0, 0, 0, 0, 297, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 95, 0, 12743, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 83968, 87040, 0, 0, 0, 483, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14336, 0, 14336, 0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 264, 0, 0, 238, 6323,
  239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 7168, 0, 7168, 7168, 7168, 7168, 7168, 7168, 7168,
  7168, 7168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7168, 7168, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 4096,
  0, 0, 0, 0, 0, 0, 582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 517, 0, 0, 0, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 561, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 270, 215, 95, 95, 95, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 172, 0, 0, 0,
  0, 0, 443, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 0, 440, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 389, 0, 0, 0, 0, 504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 575, 49152, 0, 0, 578, 0, 0,
  24576, 0, 0, 0, 0, 0, 0, 154, 215, 95, 95, 95, 95, 95, 162, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 71809, 0, 0, 95, 0, 0, 0,
  21504, 0, 0, 457, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54367, 461, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 154, 215, 95,
  95, 95, 95, 95, 224, 0, 0, 0, 0, 0, 230, 0, 0, 234, 95, 95, 0, 0, 417, 0, 419, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0,
  0, 0, 0, 326, 0, 0, 0, 95, 0, 0, 0, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 565, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 388, 0, 0, 0, 0, 87, 0, 87, 0, 0, 0, 95, 0, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 401, 0, 0,
  0, 0, 0, 0, 206, 208, 0, 0, 0, 0, 154, 215, 95, 95, 95, 95, 95, 161, 92255, 93279, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  154, 215, 95, 95, 95, 59611, 95, 0, 0, 0, 0, 0, 351, 0, 0, 0, 0, 95, 95, 95, 95, 95, 95, 95, 0, 0, 0, 0, 169, 0, 0, 0,
  0, 0, 0, 0, 0, 420, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 95, 95, 0, 0, 0, 88, 0, 88, 0, 0, 0,
  95, 0, 0, 0, 0, 95, 95, 95, 95, 95, 0, 399, 0, 0, 0, 0, 0, 266, 0, 0, 0, 0, 270, 215, 95, 95, 95, 95, 95, 95, 95, 95,
  0, 0, 0, 0, 0, 0, 171, 0, 0, 205, 0, 0, 0, 0, 0, 0, 0, 0, 154, 215, 95, 95, 95, 95, 95, 223, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 95, 236, 31744, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 95, 0, 0, 0, 418, 0, 0, 0, 0,
  95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 403, 439, 0, 441, 0, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 0,
  0, 0, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 4096, 0, 0, 290, 0, 0, 0, 0, 0, 209, 0, 0, 0, 154, 215, 95, 95,
  95, 95, 95, 318, 319, 95, 0, 0, 0, 0, 324, 0, 0, 0, 0, 0, 95, 394, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 339, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 583, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590, 591, 0, 0, 0, 0, 0, 0, 89, 0, 89, 0, 0, 0, 95, 0, 0,
  0, 0, 95, 95, 0, 0, 0, 0, 410, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 352, 0, 0, 0, 0, 95,
  95, 95, 95, 95, 95, 95, 165, 0, 0, 168, 0, 0, 0, 0, 0, 0, 390, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 233,
  0, 95, 95, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 604, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 0, 0, 0, 154, 215,
  95, 95, 95, 95, 95, 317, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 328, 0, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  100, 0, 0, 0, 0, 100, 100, 0, 0, 0, 0, 0, 309, 0, 0, 0, 0, 0, 0, 0, 270, 95, 95, 332, 0, 334, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 26624, 0, 0, 0, 0, 0, 25600, 0, 0, 0, 0, 0, 0, 154, 215, 95, 95, 95, 95, 95, 0, 0, 0, 0, 350, 0, 0, 354,
  0, 0, 95, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 421, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 229, 0, 0, 0, 0, 95, 95, 0,
  0, 0, 442, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 0, 81026, 0, 0, 0, 134, 0, 0, 0, 0, 0, 0,
  0, 95, 95, 0, 0, 0, 0, 0, 451, 0, 0, 139, 0, 142, 0, 0, 0, 0, 0, 0, 0, 142, 0, 154, 95, 95, 221, 222, 95, 95, 0, 225,
  226, 0, 0, 0, 0, 0, 0, 225, 95, 95, 237, 0, 0, 0, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 658, 0, 0, 0, 0, 0, 0, 0,
  292, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 0, 0, 0, 0, 0, 0, 570, 0, 0, 0, 0, 0, 0, 0, 577, 0, 0, 0, 0, 0, 0, 642,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 374, 0, 0, 0, 0, 0, 0, 379, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 155, 155,
  0, 0, 431, 432, 0, 0, 95, 0, 0, 436, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 0, 106496, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 7168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7168, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 63, 84, 84, 81, 0, 84, 0, 92, 92, 92, 98, 104, 104, 63, 104, 98, 98, 104, 104, 104, 0, 4212, 0, 0, 119,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 16384, 0, 0, 0, 0, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 185, 186, 0, 0, 0, 0,
  0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 105, 105, 0, 113, 99, 99, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0,
  0, 0, 0, 0, 0, 382, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 471, 0, 0, 0, 0, 0, 0, 279, 280, 0, 281, 0, 0, 0, 0, 0, 0, 95, 95,
  4096, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 437, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 438, 0, 0, 0, 0, 0, 0, 95, 0, 0,
  0, 0, 98304, 0, 0, 0, 0, 0, 0, 91, 91, 91, 97, 0, 0, 62, 0, 97, 97, 304, 0, 0, 0, 308, 0, 0, 0, 0, 0, 0, 0, 0, 270,
  95, 95, 0, 0, 406, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 347, 0, 0, 0, 639, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 300, 0, 0, 0, 0, 0, 665, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 95, 95, 113, 113, 105, 0, 4212, 0, 0,
  119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 0, 0, 0, 154, 95, 95, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0,
  0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 204, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 548, 0, 48128, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 368, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0,
  0, 411, 0, 0, 0, 0, 0, 0, 0, 94208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 474, 0, 477, 0, 0, 0, 0, 94303, 95, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 345, 0, 0, 0, 103424, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 402, 0, 0, 0, 0,
  0, 433, 0, 95, 0, 0, 0, 105472, 0, 0, 0, 0, 0, 0, 0, 423, 95, 95, 95, 95, 95, 0, 0, 0, 227, 228, 0, 0, 0, 0, 0, 95,
  95, 0, 0, 105567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 74, 0, 95, 95, 0, 0, 465, 0, 115712, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 632, 633, 0, 0, 0, 0, 0, 0, 0, 654, 0, 0, 0, 0, 0, 0, 660, 661, 0, 0, 663, 38912, 0, 0, 0, 0, 46080, 0, 0, 0,
  44032, 45056, 37888, 671, 0, 0, 674, 41984, 0, 43008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 263, 0, 0, 64, 65, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 476, 0, 106, 106, 106, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0, 0,
  422, 0, 424, 95, 95, 95, 95, 0, 0, 428, 0, 0, 127, 0, 129, 0, 88064, 0, 0, 0, 0, 71680, 78848, 0, 0, 0, 0, 0, 0, 131,
  0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 0, 270, 95, 95, 0, 0, 141, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 154, 95, 95, 0, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 8192, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 249, 250, 0, 0, 0, 0, 0, 270, 215, 95, 95, 95, 274,
  95, 95, 95, 95, 278, 291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109568, 0, 0, 0, 0, 0, 0, 0, 643, 644, 0, 0, 0, 0, 0, 648, 0,
  0, 0, 306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 95, 95, 316, 95, 95, 95, 320, 0, 0, 0, 0, 0, 325, 0, 327, 0, 0, 95, 0,
  0, 0, 0, 0, 27648, 0, 0, 0, 0, 95, 0, 0, 0, 0, 456, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 95, 0, 0, 0, 0,
  0, 0, 0, 0, 459, 0, 95, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 0, 372, 373, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 17408, 0, 0, 10320, 0, 0, 0, 0, 430, 0, 0, 0, 434, 435, 67584, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 601, 0, 0, 0, 0, 0,
  0, 608, 0, 0, 0, 0, 0, 444, 0, 95, 95, 447, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 450, 0, 0, 0, 453, 0, 95, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 460, 95, 0, 0, 0, 0, 0, 0, 445, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 29696, 0, 0, 0, 0, 154, 95, 95, 0,
  0, 0, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 0, 0, 0, 479, 0, 481, 0, 0, 0, 0, 487, 0, 0, 0, 0, 497, 0, 0, 0,
  0, 0, 0, 145, 0, 0, 0, 0, 0, 0, 154, 95, 95, 0, 0, 0, 522, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0, 0, 0, 0,
  50176, 538, 0, 0, 541, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39936, 40960, 0, 619, 0, 0, 0, 0, 0, 0, 0, 0, 584, 585, 0, 0, 0, 0,
  0, 0, 592, 0, 0, 0, 0, 0, 0, 468, 469, 0, 0, 0, 0, 0, 0, 0, 0, 0, 630, 0, 0, 0, 0, 0, 0, 0, 58368, 0, 0, 0, 0, 0, 0,
  0, 0, 631, 0, 0, 0, 0, 0, 0, 0, 488, 0, 494, 495, 0, 0, 0, 0, 499, 0, 0, 114688, 0, 0, 641, 0, 0, 0, 0, 57344, 0,
  100352, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 651, 0, 0, 0, 0, 113664, 0, 657, 0, 0, 0,
  0, 662, 99328, 0, 0, 0, 0, 0, 0, 11264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 666,
  667, 0, 668, 0, 0, 0, 0, 0, 0, 0, 673, 0, 0, 0, 0, 0, 0, 11879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 96, 96, 0,
  675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 516, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 95, 95,
  0, 95, 95, 0, 0, 0, 119, 0, 181, 0, 0, 0, 0, 0, 0, 0, 0, 617, 0, 0, 0, 0, 0, 0, 622, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0,
  76, 0, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 426, 0, 0, 0, 0, 0, 0, 4212, 0, 0, 119, 0,
  0, 0, 120, 0, 0, 0, 0, 0, 0, 0, 669, 0, 0, 0, 0, 0, 672, 0, 0, 0, 0, 0, 0, 0, 270, 215, 95, 95, 95, 95, 95, 69908, 95,
  95, 0, 333, 0, 0, 0, 0, 338, 0, 340, 341, 0, 0, 0, 0, 0, 0, 0, 446, 95, 0, 0, 0, 0, 0, 0, 0, 0, 15360, 0, 0, 0, 0, 0,
  15360, 0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 0, 95, 95, 4096, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 215,
  34008, 95, 95, 95, 95, 0, 0, 0, 0, 523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7168, 7168, 7168, 7168, 7168, 7168, 0, 0, 0,
  552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 605, 0, 0, 0, 0, 305, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 95, 95, 0, 0, 0,
  349, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 95, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61, 0, 0, 0, 0, 0, 0, 485, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 101, 0, 0, 71, 0, 101, 101, 0, 66, 0, 0, 0, 0, 0, 0, 0, 61, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0,
  449, 0, 0, 0, 452, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10320, 0, 0, 0, 0, 140, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 154, 95, 95, 174, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 0, 95, 95, 95, 95, 95, 237, 0, 0, 0,
  240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74752, 79872, 0, 0, 0, 362, 364, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 376, 377,
  0, 0, 0, 0, 0, 381, 0, 0, 383, 0, 0, 0, 0, 0, 0, 0, 0, 629, 0, 0, 0, 0, 634, 0, 0, 501, 0, 0, 0, 0, 505, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 95, 289, 4096, 0, 0, 0, 0, 519, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 537, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 95, 36959, 0, 0, 551, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0,
  0, 496, 0, 0, 0, 0, 0, 0, 581, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593, 594, 0, 596, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 270, 315, 95, 0, 0, 0, 0, 613, 614, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 357, 95, 95, 95, 95, 623, 0, 624, 625, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104448, 270, 95, 95, 0, 638, 0, 0, 0, 0, 0, 0, 0, 0, 0, 646, 0, 0, 0, 0, 0, 0, 0,
  7168, 7168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 107, 107, 107, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0,
  0, 95, 95, 95, 95, 95, 0, 427, 0, 0, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 108738, 0, 0,
  0, 198, 0, 0, 0, 0, 0, 0, 0, 95, 60511, 0, 0, 0, 0, 0, 0, 0, 0, 110667, 0, 0, 0, 0, 0, 83, 83, 237, 0, 0, 0, 0, 0, 0,
  0, 244, 245, 0, 0, 0, 0, 0, 0, 0, 132, 0, 0, 0, 0, 0, 136, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  155, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 215, 95, 95, 52497, 95, 95, 95, 95, 95, 0, 0, 66560, 323, 0, 0, 0, 0, 0,
  0, 95, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 301, 0, 0, 0, 0, 95, 73728,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 112, 0, 95, 95, 549, 550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7168, 7168,
  0, 0, 566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 387, 0, 0, 0, 664, 0, 0, 0, 0, 0, 0, 670, 0, 0, 0, 0, 0, 0, 0, 0,
  7168, 7168, 7168, 7168, 7168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 82, 82, 0, 82, 0,
  0, 0, 0, 95, 82, 82, 70, 82, 95, 95, 82, 82, 82, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 97375, 0,
  0, 0, 0, 0, 0, 0, 282, 0, 0, 0, 0, 0, 95, 95, 4096, 0, 0, 0, 0, 0, 0, 256, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 602, 603,
  0, 0, 606, 607, 0, 0, 0, 0, 0, 367, 0, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0, 91136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4212, 0, 0,
  119, 0, 0, 0, 0, 121, 0, 51200, 0, 0, 0, 0, 0, 0, 13312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 0, 0, 0, 0, 0, 0, 0, 126, 0,
  0, 0, 0, 0, 0, 133, 0, 0, 0, 0, 0, 0, 0, 0, 10437, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 0, 510, 511, 512,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 0, 0, 0, 0, 0, 0, 153, 154, 95, 156, 0, 95, 176, 0, 0, 0, 119, 0, 0, 0, 183, 0, 0,
  0, 0, 0, 0, 0, 491, 493, 0, 0, 0, 0, 0, 0, 500, 0, 267, 0, 0, 0, 270, 215, 271, 95, 95, 95, 95, 95, 95, 95, 0, 0, 0,
  0, 0, 143, 0, 0, 0, 0, 0, 0, 0, 0, 154, 95, 95, 0, 0, 0, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 95, 95, 0, 0, 0, 392,
  95, 95, 395, 396, 95, 398, 0, 0, 0, 0, 0, 0, 0, 146, 0, 0, 0, 0, 0, 154, 95, 95, 518, 0, 521, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 532, 0, 0, 0, 0, 0, 0, 506, 0, 509, 0, 0, 0, 0, 0, 0, 0, 0, 527, 0, 0, 0, 0, 0, 533, 0, 0, 580, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 10319, 10377, 0, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56320, 0, 0, 0, 0, 0, 4212,
  0, 0, 119, 0, 0, 0, 0, 0, 0, 123, 0, 0, 0, 0, 0, 0, 16384, 0, 16384, 0, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 540, 0,
  0, 543, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 0, 0, 154, 95, 95, 138, 0, 0, 138, 0, 0, 0, 0, 0, 0, 151, 152, 0, 154, 95,
  95, 157, 158, 160, 95, 163, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 344, 0, 0, 0, 72893, 0, 0, 0, 193, 0, 0, 196, 0,
  0, 0, 0, 0, 0, 0, 0, 149, 0, 0, 0, 0, 154, 95, 95, 0, 464, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107520, 0, 108,
  108, 108, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 155, 155, 155, 155, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  270, 215, 95, 95, 95, 95, 95, 95, 95, 96533, 0, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 108, 108, 0,
  108, 103, 103, 404, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 0, 0, 4212, 0, 0, 119, 0, 0, 0,
  0, 0, 0, 0, 64636, 0, 93359, 95, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 215, 95, 95, 218, 95, 95, 251, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 649, 0, 0, 268, 0, 0, 270, 215, 95, 95, 95, 95, 95, 95, 89183, 95, 0, 0, 0, 0, 0,
  0, 22528, 0, 0, 0, 0, 0, 0, 154, 95, 95, 90207, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 238, 0, 0, 0, 0, 0, 0,
  380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86216, 0, 0, 203, 0, 0, 0, 391, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 232,
  0, 0, 95, 95, 0, 405, 0, 95, 407, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 416, 0, 0, 0, 0, 0, 0, 0, 95, 425, 95, 95, 95, 0,
  0, 0, 335, 336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288, 95, 4096, 0, 0, 0, 85, 85, 0, 0, 85, 0, 85, 85, 85, 95, 109, 109,
  0, 109, 95, 95, 109, 109, 109, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 204, 154, 215, 95, 95, 95, 95, 62684, 0,
  95, 95, 0, 0, 0, 119, 180, 0, 0, 0, 0, 0, 0, 0, 0, 212, 154, 215, 95, 95, 95, 95, 95, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 247, 0, 0, 0, 0, 0, 0, 284, 0, 0, 0, 95, 95, 4096, 0, 0, 0, 0, 0, 0, 210, 0, 0, 154, 215, 95, 95, 95, 95, 95, 0,
  0, 0, 0, 0, 270, 215, 95, 272, 95, 95, 95, 95, 95, 95, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 0, 84992, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 0, 0, 0, 0, 0, 363, 0, 0, 0, 0, 0, 369, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 508, 0, 0,
  0, 0, 0, 0, 0, 0, 95, 95, 63583, 70751, 95, 0, 0, 0, 0, 81920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 413, 0, 0, 0,
  0, 0, 95, 95, 0, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 155, 155, 155, 155, 155, 0, 520, 0, 0, 0, 0, 0, 0, 0, 528,
  0, 0, 0, 0, 0, 0, 0, 148, 0, 0, 0, 0, 0, 154, 95, 95, 535, 536, 0, 0, 0, 539, 0, 0, 542, 0, 0, 0, 0, 0, 0, 0, 0,
  15360, 0, 0, 0, 15360, 0, 0, 0, 579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 0, 597, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 95310, 0, 95310, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 515, 0, 0, 0, 95, 95,
  0, 0, 0, 119, 0, 0, 182, 0, 0, 0, 0, 0, 0, 0, 155, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 265, 0, 190,
  191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 237, 0, 0, 0, 0, 0, 242, 0, 0, 0, 68608, 0, 0, 0, 0, 0, 0, 0,
  526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 0, 270, 215, 95, 95, 95, 95, 95, 95, 95, 95, 0,
  0, 0, 0, 0, 170, 0, 0, 74752, 0, 0, 0, 0, 0, 283, 0, 285, 0, 287, 95, 95, 4096, 0, 0, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 154, 215, 95, 95, 95, 95, 95, 111616, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34911, 95, 358, 95, 95, 95, 378, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 562, 0, 0, 0, 0, 0, 0, 393, 95, 95, 95, 397, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0,
  30720, 0, 0, 0, 0, 0, 270, 95, 95, 429, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 462, 0, 0, 0, 0, 553,
  554, 555, 556, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 609,
  0, 0, 612, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 626, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 636,
  86, 86, 0, 0, 86, 0, 93, 93, 93, 95, 110, 110, 0, 110, 95, 115, 110, 110, 110, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 0,
  0, 0, 258, 0, 0, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 119, 0, 0, 0, 0, 184, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0, 72, 0, 72,
  0, 0, 0, 252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 576, 0, 0, 0, 0, 0, 0, 0, 270, 215, 95, 95, 95, 95, 275, 95,
  95, 95, 0, 0, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 155, 155, 155, 155, 155, 0, 0, 0, 293, 294, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 313, 314, 0, 270, 95, 95, 0, 0, 365, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 0, 0, 0, 0, 0, 571, 0, 0, 0,
  0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329, 95, 0, 0, 0, 0, 568, 569, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 529, 530, 0, 0, 0, 0, 0, 0, 0, 0, 640, 0, 0, 0, 0, 645, 0, 0, 0, 0, 0, 0, 0, 211, 0, 154, 215, 95, 217, 95, 95,
  95, 0, 0, 652, 653, 0, 0, 0, 656, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 95, 95, 4096, 0, 0, 0, 0, 0, 0, 95, 95, 0, 0, 408,
  409, 0, 0, 0, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 154, 95, 95, 0, 610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 620,
  621, 0, 0, 0, 0, 0, 0, 627, 0, 0, 0, 0, 0, 0, 0, 0, 635, 0, 0, 0, 0, 0, 90, 0, 0, 0, 95, 0, 0, 0, 0, 95, 95, 95, 95,
  95, 0, 0, 0, 0, 101376, 0, 0, 637, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 647, 0, 0, 0, 0, 0, 0, 507, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 544, 0, 0, 0, 0, 0, 53, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 73, 0, 0, 0, 0, 73, 0, 73, 0, 0, 0, 0, 83, 0, 0, 0, 83, 83, 83, 95, 111, 111,
  110667, 111, 95, 95, 111, 111, 111, 0, 4212, 0, 0, 119, 0, 0, 0, 0, 0, 47104, 0, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 102, 0, 0, 0, 0, 102, 114, 237, 0, 0, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7168, 7168, 0, 0, 0, 0, 0, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  5120, 0, 0, 0, 0, 0, 253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18432, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  659, 0, 0, 0, 0, 0, 0, 0, 586, 587, 0, 0, 0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 572, 573, 0, 0, 0, 0, 0, 0,
  0, 0, 348, 0, 0, 0, 0, 0, 0, 0, 95, 95, 95, 95, 95, 95, 0, 0, 0, 95, 95, 76800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83143,
  0, 0, 0, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  169, 173, 177, 181, 470, 445, 212, 189, 191, 196, 199, 204, 192, 210, 200, 255, 313, 219, 233, 320, 249, 519, 218,
  223, 227, 331, 231, 237, 534, 241, 247, 568, 277, 254, 253, 259, 587, 458, 458, 254, 254, 254, 254, 265, 271, 275,
  281, 286, 297, 290, 205, 294, 307, 317, 206, 485, 299, 342, 324, 328, 386, 335, 339, 348, 360, 584, 359, 367, 364,
  368, 372, 376, 503, 379, 383, 393, 392, 397, 401, 405, 409, 413, 417, 421, 425, 431, 435, 439, 303, 449, 427, 456,
  465, 469, 496, 301, 474, 254, 482, 489, 493, 512, 600, 476, 500, 507, 511, 344, 516, 523, 476, 388, 254, 254, 254,
  254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 537, 527, 531, 184, 546, 550, 555, 185, 541, 551, 561,
  478, 542, 282, 565, 574, 578, 355, 540, 214, 593, 581, 354, 351, 460, 557, 461, 570, 261, 442, 589, 266, 597, 452,
  451, 243, 267, 267, 451, 604, 310, 205, 608, 612, 629, 636, 638, 638, 618, 644, 646, 650, 654, 640, 615, 658, 829,
  708, 701, 708, 708, 1107, 987, 659, 708, 708, 707, 708, 715, 677, 681, 670, 672, 708, 708, 734, 965, 688, 708, 708,
  708, 682, 859, 682, 695, 672, 673, 708, 708, 683, 744, 721, 672, 725, 708, 733, 733, 725, 708, 731, 1013, 998, 672,
  725, 934, 722, 725, 708, 708, 732, 723, 932, 936, 724, 860, 739, 708, 708, 710, 1117, 1044, 682, 708, 708, 735, 708,
  757, 708, 708, 708, 708, 706, 860, 682, 708, 708, 788, 708, 761, 708, 708, 708, 709, 1116, 766, 769, 773, 777, 781,
  784, 708, 708, 860, 748, 762, 708, 708, 708, 743, 912, 1007, 708, 796, 1038, 708, 708, 818, 859, 708, 841, 684, 803,
  1031, 708, 708, 1029, 861, 750, 982, 944, 823, 1030, 869, 708, 709, 708, 708, 714, 721, 670, 838, 708, 818, 708, 719,
  734, 672, 852, 858, 708, 841, 1001, 847, 868, 708, 723, 708, 732, 682, 859, 839, 876, 848, 869, 1026, 967, 819, 708,
  708, 1042, 751, 886, 708, 912, 708, 725, 727, 708, 742, 1097, 724, 708, 852, 708, 880, 847, 892, 682, 708, 881, 892,
  708, 1029, 708, 840, 891, 708, 1029, 897, 893, 1028, 840, 900, 1026, 726, 808, 812, 899, 911, 1028, 961, 708, 708,
  1056, 708, 1027, 806, 810, 814, 910, 910, 708, 807, 811, 908, 708, 805, 809, 916, 911, 805, 809, 916, 911, 805, 811,
  918, 805, 811, 918, 1084, 812, 805, 811, 1083, 811, 1091, 924, 1094, 928, 708, 708, 1068, 1019, 860, 864, 941, 945,
  951, 955, 958, 702, 973, 971, 977, 708, 786, 790, 708, 834, 663, 670, 991, 978, 708, 708, 1115, 708, 708, 1025, 995,
  708, 861, 708, 708, 826, 985, 708, 750, 632, 1005, 666, 1011, 708, 708, 708, 920, 621, 1005, 666, 1036, 708, 708,
  1128, 708, 854, 1019, 1025, 708, 842, 1000, 846, 1029, 862, 691, 623, 665, 1035, 708, 708, 854, 1018, 1024, 708, 1052,
  708, 1026, 708, 904, 813, 862, 752, 625, 887, 1037, 708, 708, 1051, 832, 1048, 1035, 708, 708, 930, 708, 1014, 1051,
  708, 708, 751, 1072, 1080, 1088, 1059, 1062, 1065, 1103, 708, 946, 937, 708, 701, 708, 733, 708, 872, 966, 708, 1076,
  1107, 708, 870, 964, 708, 1125, 708, 708, 708, 708, 1111, 733, 708, 708, 708, 799, 1098, 725, 701, 1098, 698, 708,
  708, 947, 708, 708, 786, 1098, 733, 863, 871, 965, 708, 1075, 708, 708, 965, 708, 708, 1028, 885, 708, 756, 708, 708,
  792, 1118, 1099, 708, 708, 724, 1116, 708, 708, 708, 1042, 750, 623, 708, 1122, 708, 1020, 12, 20, 36, 132, 260, 516,
  4100, 8196, 8324, 12164, 4, 65668, 4, 4, 262144, 128, 32768, 16777216, 134217728, 0, -2147483648, 16388, 32772,
  131076, 4, 262144, 192, 32768, 49156, 65540, 4, 4, 4, 4, 49348, 196, 3972, 8196, 4, 8196, 12164, -1048572, 3972,
  -262140, 32772, 8196, 49156, 196, 4, 8196, 8, 16, 32, 128, 0, -268435456, 786432, 0, 0, -2147483648, 0, 0, 0, 192, 64,
  64, 64, 64, 0, 1048576, 4194304, 25165824, 234881024, 1610612736, 524288, 0, 0, 0, 3, 8, 8, 16, 32, 0, 2, 512, 262144,
  64, 192, 64, 64, 0, 0, 8192, 0, 0, 0, 1723858968, 0, 3840, 0, 0, 0, 0, 1, 2, 0, 1048576, 234881024, 536870912,
  1073741824, 1048576, 234881024, 1073741824, 524288, 0, 0, 64, 0, 0, 0, 16, 0, 0, 3072, 0, 0, 0, 64, 64, 0, 33554432,
  134217728, 524288, 0, 3, 4, 128, 256, 49152, 33554432, 524288, 0, 0, 2, 512, 128, 32768, 0, 1024, 524288, 0, 0, 0,
  8196, 2228224, -1073741824, 0, 0, 524288, 524288, 540672, 524288, 0, 540672, 0, 4218864, 4218864, 4218864, 907280395,
  25264128, 25264128, -1071505404, 159481856, 907280395, 907280395, 159481856, 25264128, 0, 0, 3, 256, 49152, 0, 0, 0,
  3, 16384, 0, 8176, 4210688, 0, 3, 4, 384, 1310720, 905969664, 0, 0, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096,
  4194304, 32768, 4, 2097152, -2147483648, 0, 0, 1310720, 100663296, 805306368, 0, 3, 128, 256, 256, 512, 0, 1, 0, 0,
  3145728, 264241152, 159383552, 0, 0, 0, 8176, 4194304, 0, 0, 1310720, 67108864, 536870912, 0, 0, 98304, 0, 524288, 0,
  0, 24, 4194304, 0, 16384, 0, 0, 0, 1024, 0, 0, 0, 514, 98304, 25165824, 0, 0, 0, 4096, 0, 8, 4194304, 2, 1048576,
  67108864, 0, 8176, 4194304, 1048576, 67108864, 0, 2097152, 0, 0, 0, 131072, 1048576, 32768, 65536, 25165824, 0, 0, 0,
  8176, 4194304, 32768, 65536, 8388608, 16777216, 16, 96, 128, 768, 4096, 4194304, 8388608, 16777216, 0, 0, 0, 524288,
  1024, 2048, 4096, 8388608, 0, 0, 768, 3840, 1024, 2048, 16, 256, 512, 512, 0, 0, 3072, 3072, 1048576, 33554432,
  67108864, 134217728, 524288, 0, 0, 262148, 192, 49152, 18874368, 134217728, 0, 0, 1024, 33554432, 524288, 12576,
  -1744830464, 0, -1744830464, 1769472, 1769472, 1769472, 1769472, 0, 1769472, 0, 4, 2097152, 0, 8, 16, 0, 0, 0, 4,
  1723858968, 1858076696, 1771521, 1771521, 18936288, 1771521, 1771521, 0, 0, 0, 1769472, 4, 262144, 192, 49152, 65536,
  0, 64, 64, 8, 0, 288, 12288, -2147483648, 0, 480, 0, 201326592, 524288, 0, 0, 2, 8, 1048576, 16777216, 134217728, 0,
  0, 540672, 0, 196608, 1572864, 0, 0, 1048576, 33554432, 201326592, 8388608, 1610612736, 0, 0, 1, 16384, 1, 2048, 0, 0,
  0, 134217728, 0, 0, 0, 98304, 25165824, 0, 131072, 1048576, 0, 0, 0, 159383552, 0, 134217728, 0, 1024, 1024, 33554432,
  16777216, 0, -2147483648, 0, 16, 1073741824, 0, 0, 0, 128, 0, 0, 24, 0, 4152, 4152, 0, 115087, 134656, 115087, 0, 24,
  46137344, 67108864, 1536, 133120, 0, 0, 32, 0, 0, 0, 64, 0, 64, 4096, 0, 16, 32, 256, 4096, 24, 24, 4096, 16, 256,
  512, 256, 512, 256, 49152, 65536, 0, 0, 64, 64, 115087, 115087, 115087, 0, 64, 1536, 131072, 3, 12, 384, 114688, 1, 2,
  16384, 32768, 0, 0, 0, 1, 2, 16384, 0, 48, 0, 0, 64, 1024, 131072
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "END",
  "SP",
  "langValue",
  "polygonValue",
  "pointValue",
  "nodeSpec",
  "stringValue",
  "floatValue",
  "intValue",
  "dateTimeValue",
  "dateValue",
  "EOF",
  "'('",
  "')'",
  "','",
  "'1'",
  "'='",
  "'GC'",
  "'GEOMETRYCOLLECTION'",
  "'LINESTRING'",
  "'LS'",
  "'MLS'",
  "'MPG'",
  "'MPT'",
  "'MULTILINESTRING'",
  "'MULTIPOINT'",
  "'MULTIPOLYGON'",
  "'PG'",
  "'POINT'",
  "'POLYGON'",
  "'PT'",
  "'and'",
  "'andnot'",
  "'between'",
  "'boost'",
  "'boundaries-circle-excluded'",
  "'boundaries-east-excluded'",
  "'boundaries-excluded'",
  "'boundaries-included'",
  "'boundaries-latitude-excluded'",
  "'boundaries-longitude-excluded'",
  "'boundaries-north-excluded'",
  "'boundaries-south-excluded'",
  "'boundaries-west-excluded'",
  "'bw'",
  "'cached'",
  "'case-insensitive'",
  "'case-sensitive'",
  "'cn'",
  "'coll'",
  "'collation'",
  "'collection'",
  "'contains'",
  "'coordinate-system'",
  "'diacritic-insensitive'",
  "'diacritic-sensitive'",
  "'dir'",
  "'directory'",
  "'distance-weight'",
  "'doc'",
  "'document'",
  "'eq'",
  "'equal'",
  "'exact'",
  "'exclusive'",
  "'feet'",
  "'frag'",
  "'fragment'",
  "'ge'",
  "'geo'",
  "'geospatial'",
  "'gt'",
  "'inclusive'",
  "'infinity'",
  "'lang'",
  "'le'",
  "'lt'",
  "'ma'",
  "'matches'",
  "'max'",
  "'maxOccurs'",
  "'miles'",
  "'min'",
  "'minOccurs'",
  "'ne'",
  "'near'",
  "'not'",
  "'notequal'",
  "'nr'",
  "'or'",
  "'ordered'",
  "'p'",
  "'prop'",
  "'property'",
  "'proximity'",
  "'punctuation-insensitive'",
  "'punctuation-sensitive'",
  "'stemmed'",
  "'synonym'",
  "'uncached'",
  "'units'",
  "'unordered'",
  "'unstemmed'",
  "'unwildcarded'",
  "'val'",
  "'value'",
  "'w'",
  "'weight'",
  "'wgs84'",
  "'whitespace-insensitive'",
  "'whitespace-sensitive'",
  "'wildcarded'",
  "'word'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 1024
    return
      if ($result != 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 32
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 32 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 1)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 3
    let $i0 := $t * 675 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[1 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[2 + $m]
};

(:~
 : Parse the 1st loop of production rangeParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(32, $input, $state)         (: SP | 'cached' | 'collation' | 'max' | 'maxOccurs' |
                                                               'min' | 'minOccurs' | 'synonym' | 'uncached' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-rangeParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-rangeParams-1($input, $state)
};

(:~
 : Parse rangeParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(33, $input, $state)           (: SP | '(' | 'cached' | 'collation' | 'max' | 'maxOccurs' |
                                                               'min' | 'minOccurs' | 'synonym' | 'uncached' :)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(32, $input, $state)       (: SP | 'cached' | 'collation' | 'max' | 'maxOccurs' |
                                                               'min' | 'minOccurs' | 'synonym' | 'uncached' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-rangeParam($input, $state)
      let $state := p:parse-rangeParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-rangeParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rangeParams", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production geoParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geoParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(40, $input, $state)         (: SP | ')' | ',' | 'boundaries-circle-excluded' |
                                                               'boundaries-east-excluded' | 'boundaries-excluded' |
                                                               'boundaries-included' | 'boundaries-latitude-excluded' |
                                                               'boundaries-longitude-excluded' |
                                                               'boundaries-north-excluded' |
                                                               'boundaries-south-excluded' |
                                                               'boundaries-west-excluded' | 'cached' |
                                                               'coordinate-system' | 'synonym' | 'uncached' | 'units' |
                                                               'weight' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-geoParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-geoParams-1($input, $state)
};

(:~
 : Parse geoParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geoParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(39, $input, $state)           (: END | SP | '(' | 'boundaries-circle-excluded' |
                                                               'boundaries-east-excluded' | 'boundaries-excluded' |
                                                               'boundaries-included' | 'boundaries-latitude-excluded' |
                                                               'boundaries-longitude-excluded' |
                                                               'boundaries-north-excluded' |
                                                               'boundaries-south-excluded' |
                                                               'boundaries-west-excluded' | 'cached' |
                                                               'coordinate-system' | 'synonym' | 'uncached' | 'units' |
                                                               'weight' :)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(38, $input, $state)       (: SP | ',' | 'boundaries-circle-excluded' |
                                                               'boundaries-east-excluded' | 'boundaries-excluded' |
                                                               'boundaries-included' | 'boundaries-latitude-excluded' |
                                                               'boundaries-longitude-excluded' |
                                                               'boundaries-north-excluded' |
                                                               'boundaries-south-excluded' |
                                                               'boundaries-west-excluded' | 'cached' |
                                                               'coordinate-system' | 'synonym' | 'uncached' | 'units' |
                                                               'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-geoParam($input, $state)
      let $state := p:parse-geoParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-geoParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "geoParams", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production nearParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nearParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(27, $input, $state)         (: SP | 'ordered' | 'p' | 'proximity' | 'unordered' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-nearParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-nearParams-1($input, $state)
};

(:~
 : Parse nearParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nearParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(29, $input, $state)           (: SP | '(' | 'ordered' | 'p' | 'proximity' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(27, $input, $state)       (: SP | 'ordered' | 'p' | 'proximity' | 'unordered' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-nearParam($input, $state)
      let $state := p:parse-nearParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-nearParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "nearParams", $count, $begin, $end)
};

(:~
 : Parse distanceWeightParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-distanceWeightParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(59, $input, $state)                 (: 'distance-weight' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(4, $input, $state)            (: SP | floatValue :)
  let $state := p:shift(8, $input, $state)                  (: floatValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "distanceWeightParam", $count, $begin, $end)
};

(:~
 : Parse wordParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-wordParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 48) then                            (: 'case-sensitive' :)
      let $state := p:shift(48, $input, $state)             (: 'case-sensitive' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'case-insensitive' :)
      let $state := p:shift(47, $input, $state)             (: 'case-insensitive' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'diacritic-sensitive' :)
      let $state := p:shift(56, $input, $state)             (: 'diacritic-sensitive' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'diacritic-insensitive' :)
      let $state := p:shift(55, $input, $state)             (: 'diacritic-insensitive' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'punctuation-sensitive' :)
      let $state := p:shift(97, $input, $state)             (: 'punctuation-sensitive' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'punctuation-insensitive' :)
      let $state := p:shift(96, $input, $state)             (: 'punctuation-insensitive' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'whitespace-sensitive' :)
      let $state := p:shift(111, $input, $state)            (: 'whitespace-sensitive' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'whitespace-insensitive' :)
      let $state := p:shift(110, $input, $state)            (: 'whitespace-insensitive' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'stemmed' :)
      let $state := p:shift(98, $input, $state)             (: 'stemmed' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'unstemmed' :)
      let $state := p:shift(103, $input, $state)            (: 'unstemmed' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'wildcarded' :)
      let $state := p:shift(112, $input, $state)            (: 'wildcarded' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'unwildcarded' :)
      let $state := p:shift(104, $input, $state)            (: 'unwildcarded' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'exact' :)
      let $state := p:shift(64, $input, $state)             (: 'exact' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'synonym' :)
      let $state := p:shift(99, $input, $state)             (: 'synonym' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'distance-weight' :)
      let $state := p:parse-distanceWeightParam($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'lang' :)
      let $state := p:parse-langParam($input, $state)
      return $state
    else if ($state[$p:l1] = 83                             (: 'min' :)
          or $state[$p:l1] = 84) then                       (: 'minOccurs' :)
      let $state := p:parse-minOccursParam($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-maxOccursParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "wordParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production wordParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-wordParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(45, $input, $state)         (: SP | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'distance-weight' | 'exact' | 'lang' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' |
                                                               'punctuation-insensitive' | 'punctuation-sensitive' |
                                                               'stemmed' | 'synonym' | 'unstemmed' | 'unwildcarded' |
                                                               'whitespace-insensitive' | 'whitespace-sensitive' |
                                                               'wildcarded' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-wordParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-wordParams-1($input, $state)
};

(:~
 : Parse wordParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-wordParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(45, $input, $state)       (: SP | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'distance-weight' | 'exact' | 'lang' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' |
                                                               'punctuation-insensitive' | 'punctuation-sensitive' |
                                                               'stemmed' | 'synonym' | 'unstemmed' | 'unwildcarded' |
                                                               'whitespace-insensitive' | 'whitespace-sensitive' |
                                                               'wildcarded' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-wordParam($input, $state)
      let $state := p:parse-wordParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-wordParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "wordParams", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production wordExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-wordExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(49, $input, $state)     (: SP | stringValue | '(' | 'case-insensitive' |
                                                               'case-sensitive' | 'diacritic-insensitive' |
                                                               'diacritic-sensitive' | 'distance-weight' | 'exact' |
                                                               'lang' | 'max' | 'maxOccurs' | 'min' | 'minOccurs' |
                                                               'punctuation-insensitive' | 'punctuation-sensitive' |
                                                               'stemmed' | 'synonym' | 'unstemmed' | 'unwildcarded' |
                                                               'whitespace-insensitive' | 'whitespace-sensitive' |
                                                               'wildcarded' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911) then                        (: ',' stringValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SP | stringValue :)
        let $state := p:shift(7, $input, $state)            (: stringValue :)
        return p:parse-wordExpr-1($input, $state)
};

(:~
 : Parse wordExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-wordExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(24, $input, $state)           (: SP | 'w' | 'word' :)
  let $state :=
    if ($state[$p:l1] = 107) then                           (: 'w' :)
      let $state := p:shift(107, $input, $state)            (: 'w' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(113, $input, $state)            (: 'word' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shift(7, $input, $state)                  (: stringValue :)
  let $state := p:parse-wordExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(48, $input, $state)       (: SP | '(' | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'distance-weight' | 'exact' | 'lang' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' |
                                                               'punctuation-insensitive' | 'punctuation-sensitive' |
                                                               'stemmed' | 'synonym' | 'unstemmed' | 'unwildcarded' |
                                                               'whitespace-insensitive' | 'whitespace-sensitive' |
                                                               'wildcarded' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-wordParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "wordExpr", $count, $begin, $end)
};

(:~
 : Parse rangeParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 51) then                            (: 'collation' :)
      let $state := p:parse-collationParam($input, $state)
      return $state
    else if ($state[$p:l1] = 83                             (: 'min' :)
          or $state[$p:l1] = 84) then                       (: 'minOccurs' :)
      let $state := p:parse-minOccursParam($input, $state)
      return $state
    else if ($state[$p:l1] = 46) then                       (: 'cached' :)
      let $state := p:shift(46, $input, $state)             (: 'cached' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'uncached' :)
      let $state := p:shift(100, $input, $state)            (: 'uncached' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'synonym' :)
      let $state := p:shift(99, $input, $state)             (: 'synonym' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-maxOccursParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rangeParam", $count, $begin, $end)
};

(:~
 : Parse rangeOperator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeOperator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 69) then                            (: 'ge' :)
      let $state := p:shift(69, $input, $state)             (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'gt' :)
      let $state := p:shift(72, $input, $state)             (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'le' :)
      let $state := p:shift(76, $input, $state)             (: 'le' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(77, $input, $state)             (: 'lt' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "rangeOperator", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production rangeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(36, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue | 'cached' | 'collation' |
                                                               'max' | 'maxOccurs' | 'min' | 'minOccurs' | 'synonym' |
                                                               'uncached' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911                              (: ',' stringValue :)
      and $state[$p:lk] != 1039                             (: ',' floatValue :)
      and $state[$p:lk] != 1167                             (: ',' intValue :)
      and $state[$p:lk] != 1295                             (: ',' dateTimeValue :)
      and $state[$p:lk] != 1423) then                       (: ',' dateValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-tokenExpr($input, $state)
        return p:parse-rangeExpr-1($input, $state)
};

(:~
 : Parse rangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-rangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(26, $input, $state)           (: SP | 'ge' | 'gt' | 'le' | 'lt' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-rangeOperator($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:parse-rangeExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(32, $input, $state)       (: SP | 'cached' | 'collation' | 'max' | 'maxOccurs' |
                                                               'min' | 'minOccurs' | 'synonym' | 'uncached' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-rangeParam($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "rangeExpr", $count, $begin, $end)
};

(:~
 : Parse geoParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geoParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 108) then                           (: 'weight' :)
      let $state := p:parse-weightParam($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'coordinate-system' :)
      let $state := p:shift(54, $input, $state)             (: 'coordinate-system' :)
      let $state := p:lookahead1W(10, $input, $state)       (: SP | '=' :)
      let $state := p:shift(17, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(11, $input, $state)       (: SP | 'wgs84' :)
      let $state := p:shift(109, $input, $state)            (: 'wgs84' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'units' :)
      let $state := p:shift(101, $input, $state)            (: 'units' :)
      let $state := p:lookahead1W(10, $input, $state)       (: SP | '=' :)
      let $state := p:shift(17, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(18, $input, $state)       (: SP | 'feet' | 'miles' :)
      let $state :=
        if ($state[$p:l1] = 82) then                        (: 'miles' :)
          let $state := p:shift(82, $input, $state)         (: 'miles' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(66, $input, $state)         (: 'feet' :)
          return $state
      return $state
    else if ($state[$p:l1] = 39) then                       (: 'boundaries-included' :)
      let $state := p:shift(39, $input, $state)             (: 'boundaries-included' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'boundaries-excluded' :)
      let $state := p:shift(38, $input, $state)             (: 'boundaries-excluded' :)
      return $state
    else if ($state[$p:l1] = 40) then                       (: 'boundaries-latitude-excluded' :)
      let $state := p:shift(40, $input, $state)             (: 'boundaries-latitude-excluded' :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: 'boundaries-longitude-excluded' :)
      let $state := p:shift(41, $input, $state)             (: 'boundaries-longitude-excluded' :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: 'boundaries-south-excluded' :)
      let $state := p:shift(43, $input, $state)             (: 'boundaries-south-excluded' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: 'boundaries-west-excluded' :)
      let $state := p:shift(44, $input, $state)             (: 'boundaries-west-excluded' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: 'boundaries-north-excluded' :)
      let $state := p:shift(42, $input, $state)             (: 'boundaries-north-excluded' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'boundaries-east-excluded' :)
      let $state := p:shift(37, $input, $state)             (: 'boundaries-east-excluded' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'boundaries-circle-excluded' :)
      let $state := p:shift(36, $input, $state)             (: 'boundaries-circle-excluded' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: 'cached' :)
      let $state := p:shift(46, $input, $state)             (: 'cached' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'uncached' :)
      let $state := p:shift(100, $input, $state)            (: 'uncached' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'synonym' :)
      let $state := p:shift(99, $input, $state)             (: 'synonym' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "geoParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production geometryCollectionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geometryCollectionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(35, $input, $state)     (: SP | 'LINESTRING' | 'LS' | 'MLS' | 'MPG' | 'MPT' |
                                                               'MULTILINESTRING' | 'MULTIPOINT' | 'MULTIPOLYGON' |
                                                               'PG' | 'POINT' | 'POLYGON' | 'PT' :)
        let $state :=
          if ($state[$p:l1] = 29                            (: 'POINT' :)
           or $state[$p:l1] = 31) then                      (: 'PT' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-pointExpr($input, $state)
            return $state
          else if ($state[$p:l1] = 24                       (: 'MPT' :)
                or $state[$p:l1] = 26) then                 (: 'MULTIPOINT' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-multiPointExpr($input, $state)
            return $state
          else if ($state[$p:l1] = 20                       (: 'LINESTRING' :)
                or $state[$p:l1] = 21) then                 (: 'LS' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-lineStringExpr($input, $state)
            return $state
          else if ($state[$p:l1] = 22                       (: 'MLS' :)
                or $state[$p:l1] = 25) then                 (: 'MULTILINESTRING' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-multiLineStringExpr($input, $state)
            return $state
          else if ($state[$p:l1] = 28                       (: 'PG' :)
                or $state[$p:l1] = 30) then                 (: 'POLYGON' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-polygonExpr($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-multiPolygonExpr($input, $state)
            return $state
        return p:parse-geometryCollectionExpr-1($input, $state)
};

(:~
 : Parse geometryCollectionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geometryCollectionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 19) then                            (: 'GEOMETRYCOLLECTION' :)
      let $state := p:shift(19, $input, $state)             (: 'GEOMETRYCOLLECTION' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: 'GC' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:parse-geometryCollectionExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "geometryCollectionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production multiPolygonExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-multiPolygonExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(1, $input, $state)      (: SP | polygonValue :)
        let $state := p:shift(4, $input, $state)            (: polygonValue :)
        return p:parse-multiPolygonExpr-1($input, $state)
};

(:~
 : Parse multiPolygonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-multiPolygonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 27) then                            (: 'MULTIPOLYGON' :)
      let $state := p:shift(27, $input, $state)             (: 'MULTIPOLYGON' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(23, $input, $state)             (: 'MPG' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(1, $input, $state)            (: SP | polygonValue :)
  let $state := p:shift(4, $input, $state)                  (: polygonValue :)
  let $state := p:parse-multiPolygonExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "multiPolygonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production polygonExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-polygonExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(1, $input, $state)      (: SP | polygonValue :)
        let $state := p:shift(4, $input, $state)            (: polygonValue :)
        return p:parse-polygonExpr-1($input, $state)
};

(:~
 : Parse polygonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-polygonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 30) then                            (: 'POLYGON' :)
      let $state := p:shift(30, $input, $state)             (: 'POLYGON' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(28, $input, $state)             (: 'PG' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(1, $input, $state)            (: SP | polygonValue :)
  let $state := p:shift(4, $input, $state)                  (: polygonValue :)
  let $state := p:parse-polygonExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "polygonExpr", $count, $begin, $end)
};

(:~
 : Parse multiLineStringExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-multiLineStringExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 25) then                            (: 'MULTILINESTRING' :)
      let $state := p:shift(25, $input, $state)             (: 'MULTILINESTRING' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(22, $input, $state)             (: 'MLS' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "multiLineStringExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production lineStringExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-lineStringExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(2, $input, $state)      (: SP | pointValue :)
        let $state := p:shift(5, $input, $state)            (: pointValue :)
        return p:parse-lineStringExpr-1($input, $state)
};

(:~
 : Parse lineStringExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-lineStringExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 20) then                            (: 'LINESTRING' :)
      let $state := p:shift(20, $input, $state)             (: 'LINESTRING' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(21, $input, $state)             (: 'LS' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(2, $input, $state)            (: SP | pointValue :)
  let $state := p:shift(5, $input, $state)                  (: pointValue :)
  let $state := p:parse-lineStringExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "lineStringExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production multiPointExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-multiPointExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(2, $input, $state)      (: SP | pointValue :)
        let $state := p:shift(5, $input, $state)            (: pointValue :)
        return p:parse-multiPointExpr-1($input, $state)
};

(:~
 : Parse multiPointExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-multiPointExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 26) then                            (: 'MULTIPOINT' :)
      let $state := p:shift(26, $input, $state)             (: 'MULTIPOINT' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(24, $input, $state)             (: 'MPT' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(2, $input, $state)            (: SP | pointValue :)
  let $state := p:shift(5, $input, $state)                  (: pointValue :)
  let $state := p:parse-multiPointExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "multiPointExpr", $count, $begin, $end)
};

(:~
 : Parse pointExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pointExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 29) then                            (: 'POINT' :)
      let $state := p:shift(29, $input, $state)             (: 'POINT' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(31, $input, $state)             (: 'PT' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(2, $input, $state)            (: SP | pointValue :)
  let $state := p:shift(5, $input, $state)                  (: pointValue :)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "pointExpr", $count, $begin, $end)
};

(:~
 : Parse regionValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-regionValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 29                                  (: 'POINT' :)
     or $state[$p:l1] = 31) then                            (: 'PT' :)
      let $state := p:parse-pointExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 24                             (: 'MPT' :)
          or $state[$p:l1] = 26) then                       (: 'MULTIPOINT' :)
      let $state := p:parse-multiPointExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 20                             (: 'LINESTRING' :)
          or $state[$p:l1] = 21) then                       (: 'LS' :)
      let $state := p:parse-lineStringExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 22                             (: 'MLS' :)
          or $state[$p:l1] = 25) then                       (: 'MULTILINESTRING' :)
      let $state := p:parse-multiLineStringExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 28                             (: 'PG' :)
          or $state[$p:l1] = 30) then                       (: 'POLYGON' :)
      let $state := p:parse-polygonExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 23                             (: 'MPG' :)
          or $state[$p:l1] = 27) then                       (: 'MULTIPOLYGON' :)
      let $state := p:parse-multiPolygonExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-geometryCollectionExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "regionValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production geospatialExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geospatialExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(40, $input, $state)     (: SP | ')' | ',' | 'boundaries-circle-excluded' |
                                                               'boundaries-east-excluded' | 'boundaries-excluded' |
                                                               'boundaries-included' | 'boundaries-latitude-excluded' |
                                                               'boundaries-longitude-excluded' |
                                                               'boundaries-north-excluded' |
                                                               'boundaries-south-excluded' |
                                                               'boundaries-west-excluded' | 'cached' |
                                                               'coordinate-system' | 'synonym' | 'uncached' | 'units' |
                                                               'weight' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-geoParam($input, $state)
        return p:parse-geospatialExpr-1($input, $state)
};

(:~
 : Parse geospatialExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-geospatialExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(19, $input, $state)           (: SP | 'geo' | 'geospatial' :)
  let $state :=
    if ($state[$p:l1] = 70) then                            (: 'geo' :)
      let $state := p:shift(70, $input, $state)             (: 'geo' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(71, $input, $state)             (: 'geospatial' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(37, $input, $state)           (: SP | 'GC' | 'GEOMETRYCOLLECTION' | 'LINESTRING' | 'LS' |
                                                               'MLS' | 'MPG' | 'MPT' | 'MULTILINESTRING' |
                                                               'MULTIPOINT' | 'MULTIPOLYGON' | 'PG' | 'POINT' |
                                                               'POLYGON' | 'PT' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-regionValue($input, $state)
  let $state := p:parse-geospatialExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "geospatialExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production collectionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-collectionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SP | stringValue :)
        let $state := p:shift(7, $input, $state)            (: stringValue :)
        return p:parse-collectionExpr-1($input, $state)
};

(:~
 : Parse collectionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-collectionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 50) then                            (: 'coll' :)
      let $state := p:shift(50, $input, $state)             (: 'coll' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(52, $input, $state)             (: 'collection' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shift(7, $input, $state)                  (: stringValue :)
  let $state := p:parse-collectionExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "collectionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production documentExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SP | stringValue :)
        let $state := p:shift(7, $input, $state)            (: stringValue :)
        return p:parse-documentExpr-1($input, $state)
};

(:~
 : Parse documentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 60) then                            (: 'doc' :)
      let $state := p:shift(60, $input, $state)             (: 'doc' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: 'document' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shift(7, $input, $state)                  (: stringValue :)
  let $state := p:parse-documentExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "documentExpr", $count, $begin, $end)
};

(:~
 : Parse depthParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-depthParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 74) then                            (: 'infinity' :)
      let $state := p:shift(74, $input, $state)             (: 'infinity' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(16, $input, $state)             (: '1' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "depthParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production dirExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-dirExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(25, $input, $state)     (: SP | stringValue | '1' | 'infinity' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911) then                        (: ',' stringValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(3, $input, $state)      (: SP | stringValue :)
        let $state := p:shift(7, $input, $state)            (: stringValue :)
        return p:parse-dirExpr-1($input, $state)
};

(:~
 : Parse dirExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-dirExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 57) then                            (: 'dir' :)
      let $state := p:shift(57, $input, $state)             (: 'dir' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(58, $input, $state)             (: 'directory' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shift(7, $input, $state)                  (: stringValue :)
  let $state := p:parse-dirExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(13, $input, $state)       (: SP | '1' | 'infinity' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-depthParam($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "dirExpr", $count, $begin, $end)
};

(:~
 : Parse langParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-langParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(75, $input, $state)                 (: 'lang' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(0, $input, $state)            (: SP | langValue :)
  let $state := p:shift(3, $input, $state)                  (: langValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "langParam", $count, $begin, $end)
};

(:~
 : Parse valueParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-valueParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 48) then                            (: 'case-sensitive' :)
      let $state := p:shift(48, $input, $state)             (: 'case-sensitive' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'case-insensitive' :)
      let $state := p:shift(47, $input, $state)             (: 'case-insensitive' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'diacritic-sensitive' :)
      let $state := p:shift(56, $input, $state)             (: 'diacritic-sensitive' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'diacritic-insensitive' :)
      let $state := p:shift(55, $input, $state)             (: 'diacritic-insensitive' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'punctuation-sensitive' :)
      let $state := p:shift(97, $input, $state)             (: 'punctuation-sensitive' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'punctuation-insensitive' :)
      let $state := p:shift(96, $input, $state)             (: 'punctuation-insensitive' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'whitespace-sensitive' :)
      let $state := p:shift(111, $input, $state)            (: 'whitespace-sensitive' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'whitespace-insensitive' :)
      let $state := p:shift(110, $input, $state)            (: 'whitespace-insensitive' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'stemmed' :)
      let $state := p:shift(98, $input, $state)             (: 'stemmed' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'unstemmed' :)
      let $state := p:shift(103, $input, $state)            (: 'unstemmed' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'wildcarded' :)
      let $state := p:shift(112, $input, $state)            (: 'wildcarded' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'unwildcarded' :)
      let $state := p:shift(104, $input, $state)            (: 'unwildcarded' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'exact' :)
      let $state := p:shift(64, $input, $state)             (: 'exact' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'lang' :)
      let $state := p:parse-langParam($input, $state)
      return $state
    else if ($state[$p:l1] = 83                             (: 'min' :)
          or $state[$p:l1] = 84) then                       (: 'minOccurs' :)
      let $state := p:parse-minOccursParam($input, $state)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'synonym' :)
      let $state := p:shift(99, $input, $state)             (: 'synonym' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-maxOccursParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "valueParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production valueParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-valueParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(42, $input, $state)         (: SP | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'exact' | 'lang' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'punctuation-insensitive' |
                                                               'punctuation-sensitive' | 'stemmed' | 'synonym' |
                                                               'unstemmed' | 'unwildcarded' | 'whitespace-insensitive' |
                                                               'whitespace-sensitive' | 'wildcarded' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-valueParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-valueParams-1($input, $state)
};

(:~
 : Parse valueParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-valueParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(42, $input, $state)       (: SP | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'exact' | 'lang' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'punctuation-insensitive' |
                                                               'punctuation-sensitive' | 'stemmed' | 'synonym' |
                                                               'unstemmed' | 'unwildcarded' | 'whitespace-insensitive' |
                                                               'whitespace-sensitive' | 'wildcarded' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-valueParam($input, $state)
      let $state := p:parse-valueParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-valueParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "valueParams", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production valueExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-valueExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(50, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue | '(' | 'case-insensitive' |
                                                               'case-sensitive' | 'diacritic-insensitive' |
                                                               'diacritic-sensitive' | 'exact' | 'lang' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' |
                                                               'punctuation-insensitive' | 'punctuation-sensitive' |
                                                               'stemmed' | 'synonym' | 'unstemmed' | 'unwildcarded' |
                                                               'whitespace-insensitive' | 'whitespace-sensitive' |
                                                               'wildcarded' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911                              (: ',' stringValue :)
      and $state[$p:lk] != 1039                             (: ',' floatValue :)
      and $state[$p:lk] != 1167                             (: ',' intValue :)
      and $state[$p:lk] != 1295                             (: ',' dateTimeValue :)
      and $state[$p:lk] != 1423) then                       (: ',' dateValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-tokenExpr($input, $state)
        return p:parse-valueExpr-1($input, $state)
};

(:~
 : Parse valueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-valueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(23, $input, $state)           (: SP | 'val' | 'value' :)
  let $state :=
    if ($state[$p:l1] = 105) then                           (: 'val' :)
      let $state := p:shift(105, $input, $state)            (: 'val' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(106, $input, $state)            (: 'value' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:parse-valueExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(43, $input, $state)       (: SP | '(' | 'case-insensitive' | 'case-sensitive' |
                                                               'diacritic-insensitive' | 'diacritic-sensitive' |
                                                               'exact' | 'lang' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'punctuation-insensitive' |
                                                               'punctuation-sensitive' | 'stemmed' | 'synonym' |
                                                               'unstemmed' | 'unwildcarded' | 'whitespace-insensitive' |
                                                               'whitespace-sensitive' | 'wildcarded' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-valueParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "valueExpr", $count, $begin, $end)
};

(:~
 : Parse containsExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-containsExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(15, $input, $state)           (: SP | 'cn' | 'contains' :)
  let $state :=
    if ($state[$p:l1] = 49) then                            (: 'cn' :)
      let $state := p:shift(49, $input, $state)             (: 'cn' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(53, $input, $state)             (: 'contains' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: SP | ',' :)
  let $state := p:shift(15, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "containsExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production matchExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-matchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-tokenExpr($input, $state)
        return p:parse-matchExpr-1($input, $state)
};

(:~
 : Parse matchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-matchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(20, $input, $state)           (: SP | 'ma' | 'matches' :)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'ma' :)
      let $state := p:shift(78, $input, $state)             (: 'ma' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(79, $input, $state)             (: 'matches' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:parse-matchExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "matchExpr", $count, $begin, $end)
};

(:~
 : Parse betweenParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-betweenParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 73) then                            (: 'inclusive' :)
      let $state := p:shift(73, $input, $state)             (: 'inclusive' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(65, $input, $state)             (: 'exclusive' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "betweenParams", $count, $begin, $end)
};

(:~
 : Parse betweenExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-betweenExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(14, $input, $state)           (: SP | 'between' | 'bw' :)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: 'bw' :)
      let $state := p:shift(45, $input, $state)             (: 'bw' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(34, $input, $state)             (: 'between' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: SP | ',' :)
  let $state := p:shift(15, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: SP | ')' | ',' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(17, $input, $state)       (: SP | 'exclusive' | 'inclusive' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-betweenParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "betweenExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production notEqualExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-notEqualExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(34, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue | '(' | 'collation' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' | 'weight' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911                              (: ',' stringValue :)
      and $state[$p:lk] != 1039                             (: ',' floatValue :)
      and $state[$p:lk] != 1167                             (: ',' intValue :)
      and $state[$p:lk] != 1295                             (: ',' dateTimeValue :)
      and $state[$p:lk] != 1423) then                       (: ',' dateValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-tokenExpr($input, $state)
        return p:parse-notEqualExpr-1($input, $state)
};

(:~
 : Parse notEqualExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-notEqualExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(21, $input, $state)           (: SP | 'ne' | 'notequal' :)
  let $state :=
    if ($state[$p:l1] = 85) then                            (: 'ne' :)
      let $state := p:shift(85, $input, $state)             (: 'ne' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(88, $input, $state)             (: 'notequal' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:parse-notEqualExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(31, $input, $state)       (: SP | '(' | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-equalParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "notEqualExpr", $count, $begin, $end)
};

(:~
 : Parse weightParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-weightParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(108, $input, $state)                (: 'weight' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(4, $input, $state)            (: SP | floatValue :)
  let $state := p:shift(8, $input, $state)                  (: floatValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "weightParam", $count, $begin, $end)
};

(:~
 : Try parsing weightParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-weightParam($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(108, $input, $state)               (: 'weight' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shiftT(17, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(4, $input, $state)            (: SP | floatValue :)
  let $state := p:shiftT(8, $input, $state)                 (: floatValue :)
  return $state
};

(:~
 : Parse maxOccursParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-maxOccursParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'max' :)
      let $state := p:shift(80, $input, $state)             (: 'max' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(81, $input, $state)             (: 'maxOccurs' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(5, $input, $state)            (: SP | intValue :)
  let $state := p:shift(9, $input, $state)                  (: intValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "maxOccursParam", $count, $begin, $end)
};

(:~
 : Try parsing maxOccursParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-maxOccursParam($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'max' :)
      let $state := p:shiftT(80, $input, $state)            (: 'max' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(81, $input, $state)            (: 'maxOccurs' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shiftT(17, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(5, $input, $state)            (: SP | intValue :)
  let $state := p:shiftT(9, $input, $state)                 (: intValue :)
  return $state
};

(:~
 : Parse minOccursParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-minOccursParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 83) then                            (: 'min' :)
      let $state := p:shift(83, $input, $state)             (: 'min' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(84, $input, $state)             (: 'minOccurs' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(5, $input, $state)            (: SP | intValue :)
  let $state := p:shift(9, $input, $state)                  (: intValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "minOccursParam", $count, $begin, $end)
};

(:~
 : Try parsing minOccursParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-minOccursParam($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 83) then                            (: 'min' :)
      let $state := p:shiftT(83, $input, $state)            (: 'min' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(84, $input, $state)            (: 'minOccurs' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shiftT(17, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(5, $input, $state)            (: SP | intValue :)
  let $state := p:shiftT(9, $input, $state)                 (: intValue :)
  return $state
};

(:~
 : Parse collationParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-collationParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(51, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shift(7, $input, $state)                  (: stringValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "collationParam", $count, $begin, $end)
};

(:~
 : Try parsing collationParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-collationParam($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(51, $input, $state)                (: 'collation' :)
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shiftT(17, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(3, $input, $state)            (: SP | stringValue :)
  let $state := p:shiftT(7, $input, $state)                 (: stringValue :)
  return $state
};

(:~
 : Parse equalParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-equalParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 51) then                            (: 'collation' :)
      let $state := p:parse-collationParam($input, $state)
      return $state
    else if ($state[$p:l1] = 83                             (: 'min' :)
          or $state[$p:l1] = 84) then                       (: 'minOccurs' :)
      let $state := p:parse-minOccursParam($input, $state)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'weight' :)
      let $state := p:parse-weightParam($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-maxOccursParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "equalParam", $count, $begin, $end)
};

(:~
 : Try parsing equalParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-equalParam($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 51) then                            (: 'collation' :)
      let $state := p:try-collationParam($input, $state)
      return $state
    else if ($state[$p:l1] = 83                             (: 'min' :)
          or $state[$p:l1] = 84) then                       (: 'minOccurs' :)
      let $state := p:try-minOccursParam($input, $state)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'weight' :)
      let $state := p:try-weightParam($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-maxOccursParam($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production equalParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-equalParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shift(15, $input, $state)               (: ',' :)
    let $state := p:lookahead1W(30, $input, $state)         (: SP | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-equalParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:parse-equalParams-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production equalParams (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-equalParams-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(9, $input, $state)          (: SP | ',' :)
    let $state := p:shiftT(15, $input, $state)              (: ',' :)
    let $state := p:lookahead1W(30, $input, $state)         (: SP | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
    let $state := p:try-equalParam($input, $state)
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        p:try-equalParams-1($input, $state)
};

(:~
 : Parse equalParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-equalParams($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shift(13, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: SP | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-equalParam($input, $state)
      let $state := p:parse-equalParams-1($input, $state)
      let $state := p:shift(14, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-equalParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "equalParams", $count, $begin, $end)
};

(:~
 : Try parsing equalParams.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-equalParams($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 13) then                            (: '(' :)
      let $state := p:shiftT(13, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: SP | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
      let $state := p:try-equalParam($input, $state)
      let $state := p:try-equalParams-1($input, $state)
      let $state := p:shiftT(14, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-equalParam($input, $state)
      return $state
  return $state
};

(:~
 : Parse tokenExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-tokenExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 7) then                             (: stringValue :)
      let $state := p:shift(7, $input, $state)              (: stringValue :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: intValue :)
      let $state := p:shift(9, $input, $state)              (: intValue :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: floatValue :)
      let $state := p:shift(8, $input, $state)              (: floatValue :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: dateValue :)
      let $state := p:shift(11, $input, $state)             (: dateValue :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(10, $input, $state)             (: dateTimeValue :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "tokenExpr", $count, $begin, $end)
};

(:~
 : Try parsing tokenExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-tokenExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 7) then                             (: stringValue :)
      let $state := p:shiftT(7, $input, $state)             (: stringValue :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: intValue :)
      let $state := p:shiftT(9, $input, $state)             (: intValue :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: floatValue :)
      let $state := p:shiftT(8, $input, $state)             (: floatValue :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: dateValue :)
      let $state := p:shiftT(11, $input, $state)            (: dateValue :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(10, $input, $state)            (: dateTimeValue :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production equalExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-equalExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(34, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue | '(' | 'collation' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' | 'weight' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911                              (: ',' stringValue :)
      and $state[$p:lk] != 1039                             (: ',' floatValue :)
      and $state[$p:lk] != 1167                             (: ',' intValue :)
      and $state[$p:lk] != 1295                             (: ',' dateTimeValue :)
      and $state[$p:lk] != 1423) then                       (: ',' dateValue :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-tokenExpr($input, $state)
        return p:parse-equalExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production equalExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-equalExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(34, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue | '(' | 'collation' | 'max' |
                                                               'maxOccurs' | 'min' | 'minOccurs' | 'weight' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 911                              (: ',' stringValue :)
      and $state[$p:lk] != 1039                             (: ',' floatValue :)
      and $state[$p:lk] != 1167                             (: ',' intValue :)
      and $state[$p:lk] != 1295                             (: ',' dateTimeValue :)
      and $state[$p:lk] != 1423) then                       (: ',' dateValue :)
        $state
      else
        let $state := p:shiftT(15, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
        let $state := p:try-tokenExpr($input, $state)
        return p:try-equalExpr-1($input, $state)
};

(:~
 : Parse equalExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-equalExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(6, $input, $state)                  (: nodeSpec :)
  let $state := p:lookahead1W(16, $input, $state)           (: SP | 'eq' | 'equal' :)
  let $state :=
    if ($state[$p:l1] = 62) then                            (: 'eq' :)
      let $state := p:shift(62, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: 'equal' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-tokenExpr($input, $state)
  let $state := p:parse-equalExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shift(15, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(31, $input, $state)       (: SP | '(' | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-equalParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "equalExpr", $count, $begin, $end)
};

(:~
 : Try parsing equalExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-equalExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(6, $input, $state)                 (: nodeSpec :)
  let $state := p:lookahead1W(16, $input, $state)           (: SP | 'eq' | 'equal' :)
  let $state :=
    if ($state[$p:l1] = 62) then                            (: 'eq' :)
      let $state := p:shiftT(62, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(63, $input, $state)            (: 'equal' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shiftT(13, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: SP | stringValue | floatValue | intValue |
                                                               dateTimeValue | dateValue :)
  let $state := p:try-tokenExpr($input, $state)
  let $state := p:try-equalExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: ',' :)
      let $state := p:shiftT(15, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(31, $input, $state)       (: SP | '(' | 'collation' | 'max' | 'maxOccurs' | 'min' |
                                                               'minOccurs' | 'weight' :)
      let $state := p:try-equalParams($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shiftT(14, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse propertyExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-propertyExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 93) then                            (: 'prop' :)
      let $state := p:shift(93, $input, $state)             (: 'prop' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(94, $input, $state)             (: 'property' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "propertyExpr", $count, $begin, $end)
};

(:~
 : Parse fragmentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-fragmentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 67) then                            (: 'frag' :)
      let $state := p:shift(67, $input, $state)             (: 'frag' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(68, $input, $state)             (: 'fragment' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "fragmentExpr", $count, $begin, $end)
};

(:~
 : Parse boostExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-boostExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(35, $input, $state)                 (: 'boost' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: SP | ',' :)
  let $state := p:shift(15, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "boostExpr", $count, $begin, $end)
};

(:~
 : Parse proximityParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-proximityParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 92) then                            (: 'p' :)
      let $state := p:shift(92, $input, $state)             (: 'p' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(95, $input, $state)             (: 'proximity' :)
      return $state
  let $state := p:lookahead1W(10, $input, $state)           (: SP | '=' :)
  let $state := p:shift(17, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(5, $input, $state)            (: SP | intValue :)
  let $state := p:shift(9, $input, $state)                  (: intValue :)
  let $end := $state[$p:e0]
  return p:reduce($state, "proximityParam", $count, $begin, $end)
};

(:~
 : Parse nearParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nearParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 92                                  (: 'p' :)
     or $state[$p:l1] = 95) then                            (: 'proximity' :)
      let $state := p:parse-proximityParam($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-orderParam($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "nearParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production nearExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nearExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(27, $input, $state)     (: SP | 'ordered' | 'p' | 'proximity' | 'unordered' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-nearParam($input, $state)
        return p:parse-nearExpr-1($input, $state)
};

(:~
 : Parse nearExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nearExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 89) then                            (: 'nr' :)
      let $state := p:shift(89, $input, $state)             (: 'nr' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(86, $input, $state)             (: 'near' :)
      return $state
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: SP | ',' :)
  let $state := p:shift(15, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:parse-nearExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "nearExpr", $count, $begin, $end)
};

(:~
 : Parse andNotExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-andNotExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(33, $input, $state)                 (: 'andnot' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: SP | ',' :)
  let $state := p:shift(15, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "andNotExpr", $count, $begin, $end)
};

(:~
 : Parse notExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-notExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(87, $input, $state)                 (: 'not' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(8, $input, $state)            (: SP | ')' :)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "notExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production orExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-orExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(41, $input, $state)     (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-mqlExpr($input, $state)
        return p:parse-orExpr-1($input, $state)
};

(:~
 : Parse orExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-orExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(90, $input, $state)                 (: 'or' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(46, $input, $state)           (: SP | nodeSpec | stringValue | ')' | ',' | 'and' |
                                                               'andnot' | 'boost' | 'coll' | 'collection' | 'dir' |
                                                               'directory' | 'doc' | 'document' | 'frag' | 'fragment' |
                                                               'near' | 'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 14                            (: ')' :)
         and $state[$p:l1] != 15) then                      (: ',' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-mqlExpr($input, $state)
      return $state
    else
      $state
  let $state := p:parse-orExpr-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "orExpr", $count, $begin, $end)
};

(:~
 : Parse orderParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-orderParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 91) then                            (: 'ordered' :)
      let $state := p:shift(91, $input, $state)             (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(102, $input, $state)            (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "orderParam", $count, $begin, $end)
};

(:~
 : Parse andParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-andParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-orderParam($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "andParam", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production andExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-andExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    let $state :=
      if ($state[$p:l1] = 15) then                          (: ',' :)
        let $state := p:lookahead2W(47, $input, $state)     (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'ordered' | 'prop' | 'property' |
                                                               'unordered' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 14                                (: ')' :)
       or $state[$p:lk] = 11663                             (: ',' 'ordered' :)
       or $state[$p:lk] = 13071) then                       (: ',' 'unordered' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(41, $input, $state)     (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-mqlExpr($input, $state)
        return p:parse-andExpr-1($input, $state)
};

(:~
 : Parse the 2nd loop of production andExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-andExpr-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: SP | ')' | ',' :)
    return
      if ($state[$p:l1] != 15) then                         (: ',' :)
        $state
      else
        let $state := p:shift(15, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: SP | 'ordered' | 'unordered' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-andParam($input, $state)
        return p:parse-andExpr-2($input, $state)
};

(:~
 : Parse andExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-andExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(32, $input, $state)                 (: 'and' :)
  let $state := p:lookahead1W(7, $input, $state)            (: SP | '(' :)
  let $state := p:shift(13, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(46, $input, $state)           (: SP | nodeSpec | stringValue | ')' | ',' | 'and' |
                                                               'andnot' | 'boost' | 'coll' | 'collection' | 'dir' |
                                                               'directory' | 'doc' | 'document' | 'frag' | 'fragment' |
                                                               'near' | 'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 14                            (: ')' :)
         and $state[$p:l1] != 15) then                      (: ',' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-mqlExpr($input, $state)
      return $state
    else
      $state
  let $state := p:parse-andExpr-1($input, $state)
  let $state := p:parse-andExpr-2($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "andExpr", $count, $begin, $end)
};

(:~
 : Parse mqlExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-mqlExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 6) then                             (: nodeSpec :)
      let $state := p:lookahead2W(44, $input, $state)       (: SP | 'between' | 'bw' | 'cn' | 'contains' | 'eq' |
                                                               'equal' | 'ge' | 'geo' | 'geospatial' | 'gt' | 'le' |
                                                               'lt' | 'ma' | 'matches' | 'ne' | 'notequal' | 'val' |
                                                               'value' | 'w' | 'word' :)
      let $state :=
        if ($state[$p:lk] = 7942                            (: nodeSpec 'eq' :)
         or $state[$p:lk] = 8070) then                      (: nodeSpec 'equal' :)
          let $state := p:lookahead3W(7, $input, $state)    (: SP | '(' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 220934                         (: nodeSpec 'eq' '(' :)
          or $state[$p:lk] = 221062) then                   (: nodeSpec 'equal' '(' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-equalExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -9, 0)
            else
              p:memoize($backtrack, $state, -10, 0)
    else
      $state
  let $state :=
    if ($state[$p:lk] = 32) then                            (: 'and' :)
      let $state := p:parse-andExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 90) then                       (: 'or' :)
      let $state := p:parse-orExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 87) then                       (: 'not' :)
      let $state := p:parse-notExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: 'andnot' :)
      let $state := p:parse-andNotExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 86                             (: 'near' :)
          or $state[$p:lk] = 89) then                       (: 'nr' :)
      let $state := p:parse-nearExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: 'boost' :)
      let $state := p:parse-boostExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 67                             (: 'frag' :)
          or $state[$p:lk] = 68) then                       (: 'fragment' :)
      let $state := p:parse-fragmentExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 93                             (: 'prop' :)
          or $state[$p:lk] = 94) then                       (: 'property' :)
      let $state := p:parse-propertyExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -9) then
      let $state := p:parse-equalExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -10) then
      let $state := p:parse-equalExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 10886                          (: nodeSpec 'ne' :)
          or $state[$p:lk] = 11270) then                    (: nodeSpec 'notequal' :)
      let $state := p:parse-notEqualExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 4358                           (: nodeSpec 'between' :)
          or $state[$p:lk] = 5766) then                     (: nodeSpec 'bw' :)
      let $state := p:parse-betweenExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 9990                           (: nodeSpec 'ma' :)
          or $state[$p:lk] = 10118) then                    (: nodeSpec 'matches' :)
      let $state := p:parse-matchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 6278                           (: nodeSpec 'cn' :)
          or $state[$p:lk] = 6790) then                     (: nodeSpec 'contains' :)
      let $state := p:parse-containsExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 13446                          (: nodeSpec 'val' :)
          or $state[$p:lk] = 13574) then                    (: nodeSpec 'value' :)
      let $state := p:parse-valueExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 57                             (: 'dir' :)
          or $state[$p:lk] = 58) then                       (: 'directory' :)
      let $state := p:parse-dirExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 60                             (: 'doc' :)
          or $state[$p:lk] = 61) then                       (: 'document' :)
      let $state := p:parse-documentExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50                             (: 'coll' :)
          or $state[$p:lk] = 52) then                       (: 'collection' :)
      let $state := p:parse-collectionExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8966                           (: nodeSpec 'geo' :)
          or $state[$p:lk] = 9094) then                     (: nodeSpec 'geospatial' :)
      let $state := p:parse-geospatialExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 13702                          (: nodeSpec 'w' :)
          or $state[$p:lk] = 14470) then                    (: nodeSpec 'word' :)
      let $state := p:parse-wordExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7) then                        (: stringValue :)
      let $state := p:shift(7, $input, $state)              (: stringValue :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-rangeExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "mqlExpr", $count, $begin, $end)
};

(:~
 : Parse mql.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-mql($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(41, $input, $state)           (: SP | nodeSpec | stringValue | 'and' | 'andnot' |
                                                               'boost' | 'coll' | 'collection' | 'dir' | 'directory' |
                                                               'doc' | 'document' | 'frag' | 'fragment' | 'near' |
                                                               'not' | 'nr' | 'or' | 'prop' | 'property' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-mqlExpr($input, $state)
  let $state := p:lookahead1W(6, $input, $state)            (: SP | EOF :)
  let $state := p:shift(12, $input, $state)                 (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "mql", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        if ($error/@e = $begin) then
          ""
        else
          concat("after successfully scanning ", string($error/@e - $begin), " characters "),
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:shift, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shiftT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $begin,
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 2) then                                 (: SP :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 128 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 16384 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo{$state[$p:error]/@*, $state[$p:memo]/value}
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 1 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 1 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol mql from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-mql($s as xs:string) as item()*
{
  let $state := p:parse-mql($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol nearParams from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-nearParams($s as xs:string) as item()*
{
  let $state := p:parse-nearParams($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol geoParams from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-geoParams($s as xs:string) as item()*
{
  let $state := p:parse-geoParams($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol rangeParams from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-rangeParams($s as xs:string) as item()*
{
  let $state := p:parse-rangeParams($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
